# PL-SQL-assessment-
#Code
--------------------------------------------------------------------------------
-- DEMO: PL/SQL Collections, Records, and GOTO
-- Works directly in Oracle Database (SQL Developer or Live SQL)
-- 27259 Montell Edmond Reeves
--------------------------------------------------------------------------------

SET SERVEROUTPUT ON;
-- Optional cleanup if rerunning
BEGIN
  FOR t IN (SELECT table_name FROM user_tables 
             WHERE table_name IN (
               'PRODUCTS', 'STG_INVENTORY_ADJUSTMENTS',
               'FINAL_INVENTORY_ADJUSTMENTS', 'INVENTORY_ERRORS')) LOOP
    EXECUTE IMMEDIATE 'DROP TABLE ' || t.table_name || ' CASCADE CONSTRAINTS';
  END LOOP;
EXCEPTION
  WHEN OTHERS THEN NULL;
END;
/

--------------------------------------------------------------------------------
-- 1. TABLE CREATION
--------------------------------------------------------------------------------

CREATE TABLE products (
  product_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sku          VARCHAR2(40) UNIQUE,
  name         VARCHAR2(200)
);

CREATE TABLE stg_inventory_adjustments (
  batch_id     NUMBER,
  row_id       NUMBER,
  product_sku  VARCHAR2(40),
  qty_change   NUMBER,
  reason       VARCHAR2(200)
);

CREATE TABLE final_inventory_adjustments (
  adjustment_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id    NUMBER,
  qty_change    NUMBER,
  reason        VARCHAR2(200),
  processed_date DATE
);

CREATE TABLE inventory_errors (
  error_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  batch_id     NUMBER,
  row_id       NUMBER,
  error_code   VARCHAR2(20),
  error_msg    VARCHAR2(400),
  logged_date  DATE
);

--------------------------------------------------------------------------------
-- 2. SAMPLE DATA
--------------------------------------------------------------------------------

INSERT INTO products (sku, name) VALUES ('A100', 'Blue Widget');
INSERT INTO products (sku, name) VALUES ('B200', 'Red Widget');
INSERT INTO products (sku, name) VALUES ('C300', 'Green Widget');

INSERT INTO stg_inventory_adjustments VALUES (1, 1, 'A100', 10,  'Stock count correction');
INSERT INTO stg_inventory_adjustments VALUES (1, 2, 'B200', -5,  'Customer return');
INSERT INTO stg_inventory_adjustments VALUES (1, 3, 'X999', 8,   'Unknown SKU');  -- invalid SKU
INSERT INTO stg_inventory_adjustments VALUES (1, 4, 'C300', NULL, 'Missing quantity'); -- invalid qty
INSERT INTO stg_inventory_adjustments VALUES (1, 5, 'A100', 0,   'Zero quantity'); -- invalid qty

COMMIT;

--------------------------------------------------------------------------------
-- 3. PROCEDURE IMPLEMENTATION
--------------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE process_inventory_adjustments(p_batch_id IN NUMBER) IS
  -- RECORD for staging data
  TYPE t_adj_rec IS RECORD (
    row_id       NUMBER,
    product_sku  VARCHAR2(40),
    qty_change   NUMBER,
    reason       VARCHAR2(200)
  );

  -- Associative array for staging
  TYPE t_adj_tab IS TABLE OF t_adj_rec INDEX BY PLS_INTEGER;
  v_staging_tab t_adj_tab;

  -- Nested table for valid rows
  TYPE t_final_tab IS TABLE OF final_inventory_adjustments%ROWTYPE;
  v_valid_tab t_final_tab := t_final_tab();

  -- Local variables
  v_prod_id   products.product_id%TYPE;
  v_processed NUMBER := 0;
  v_skipped   NUMBER := 0;

BEGIN
  -- Fetch all rows for given batch into collection
  SELECT row_id, product_sku, qty_change, reason
  BULK COLLECT INTO v_staging_tab
  FROM stg_inventory_adjustments
  WHERE batch_id = p_batch_id;

  DBMS_OUTPUT.PUT_LINE('Fetched ' || v_staging_tab.COUNT || ' rows.');

  -- Loop through collection
  FOR i IN v_staging_tab.FIRST .. v_staging_tab.LAST LOOP
    DECLARE
      v_row t_adj_rec := v_staging_tab(i);
    BEGIN
      -- Lookup product ID
      SELECT product_id INTO v_prod_id
      FROM products
      WHERE sku = v_row.product_sku;

      -- Validate quantity
      IF v_row.qty_change IS NULL OR v_row.qty_change = 0 THEN
        GOTO log_error;
      END IF;

      -- Valid row â†’ add to nested table
      v_valid_tab.EXTEND;
      v_valid_tab(v_valid_tab.LAST).product_id := v_prod_id;
      v_valid_tab(v_valid_tab.LAST).qty_change := v_row.qty_change;
      v_valid_tab(v_valid_tab.LAST).reason := v_row.reason;
      v_valid_tab(v_valid_tab.LAST).processed_date := SYSDATE;

      v_processed := v_processed + 1;
      CONTINUE;

      <<log_error>>
      NULL; -- placeholder for label only

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        INSERT INTO inventory_errors (batch_id, row_id, error_code, error_msg, logged_date)
        VALUES (p_batch_id, v_row.row_id, 'E001', 'Invalid SKU: ' || v_row.product_sku, SYSDATE);
        v_skipped := v_skipped + 1;
        CONTINUE;
      WHEN OTHERS THEN
        INSERT INTO inventory_errors (batch_id, row_id, error_code, error_msg, logged_date)
        VALUES (p_batch_id, v_row.row_id, 'E999', SQLERRM, SYSDATE);
        v_skipped := v_skipped + 1;
        CONTINUE;
    END;
  END LOOP;

  -- Bulk insert valid data
  IF v_valid_tab.COUNT > 0 THEN
    FORALL j IN 1 .. v_valid_tab.COUNT
      INSERT INTO final_inventory_adjustments (product_id, qty_change, reason, processed_date)
      VALUES (v_valid_tab(j).product_id, v_valid_tab(j).qty_change, v_valid_tab(j).reason, v_valid_tab(j).processed_date);
  END IF;

  COMMIT;

  DBMS_OUTPUT.PUT_LINE('Processed: ' || v_processed);
  DBMS_OUTPUT.PUT_LINE('Skipped:   ' || v_skipped);
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    ROLLBACK;
END;
/
SHOW ERRORS;

--------------------------------------------------------------------------------
-- 4. EXECUTE PROCEDURE
--------------------------------------------------------------------------------

BEGIN
  process_inventory_adjustments(1);
END;
/

--------------------------------------------------------------------------------
-- 5. VIEW RESULTS
--------------------------------------------------------------------------------

PROMPT === Final Adjustments ===
SELECT * FROM final_inventory_adjustments;

PROMPT === Error Log ===
SELECT * FROM inventory_errors;
